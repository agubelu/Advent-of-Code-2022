use itertools::Itertools;
use scanf::sscanf;
use rayon::prelude::*;
use crate::{Solution, SolutionPair};
use Material::*;
use std::cmp::max;
use std::fs::read_to_string;

///////////////////////////////////////////////////////////////////////////////

type RecipePart = (u32, Material);

#[derive(Copy, Clone)]
enum Material {
    Ore = 0,
    Clay = 1,
    Obsidian = 2,
    Geode = 3,
}

struct Blueprint {
    id: u32,
    robot_recipes: [Vec<RecipePart>; 4],
}

#[derive(Copy, Clone)]
struct SearchState {
    time_remaining: u32,
    robots: [u32; 4],
    materials: [u32; 4],
}

pub fn solve() -> SolutionPair {
    let blueprints = read_to_string("input/day19.txt").unwrap()
        .lines()
        .map(Blueprint::from_line)
        .collect_vec();

    let sol1 = blueprints.par_iter()
        .map(|bp| (bp.id * get_blueprint_score(bp, 24)))
        .sum::<u32>();

    let sol2 = blueprints.par_iter()
        .take(3)
        .map(|bp| (get_blueprint_score(bp, 32)))
        .product::<u32>();

    (Solution::from(sol1), Solution::from(sol2))
}

// Nice wrapper around the main search function
fn get_blueprint_score(blueprint: &Blueprint, time_remaining: u32) -> u32 {
    let state = SearchState { time_remaining, robots: [1,0,0,0], materials: [0,0,0,0] };
    let max_materials = get_max_materials(blueprint);
    run_for_blueprint(&state, blueprint, &max_materials, None, 0)
}

// Recursive search function
fn run_for_blueprint(
    state: &SearchState, 
    blueprint: &Blueprint, 
    max_materials: &[u32], 
    prev_skipped: Option<&Vec<usize>>,
    best_so_far: u32
) -> u32 {
    if state.time_remaining == 1 {
        // Even if we built a robot now there's not enough time for it to produce anything,
        // we can stop searching here and add whatever the geode robots would have produced next
        return state.materials[3] + state.robots[3];
    }

    // Is the optimistic expected score for this branch worse than the best we have
    // already guaranteed somewhere else? If so, prune it.
    if optimistic_best(state, Geode) < best_so_far {
        return 0;
    }

    // Is it impossible for us to generate enough obsidian to generate any more
    // geode robots? If that's the case, we already know the final result
    let min_obsidian = max_materials[2];
    if optimistic_best(state, Obsidian) < min_obsidian {
        return state.materials[3] + state.robots[3] * state.time_remaining;
    }

    // Make the new state for this turn and update the material count and time remaining
    let mut new_state = *state;
    new_state.time_remaining -= 1;
    (0..4).for_each(|i| new_state.materials[i] += new_state.robots[i]);

    // If a geode robot can be constructed, it is mandatory to do it ASAP
    if state.can_build_robot(Geode as usize, blueprint, max_materials) {
        new_state.build_robot(Geode as usize, blueprint);
        return run_for_blueprint(&new_state, blueprint, max_materials, None, best_so_far);
    }

    // Determine which non-geode robots can be made this turn
    // We have already ruled out geode robots, they fall under the previous condition
    let robots_available = (0..3).filter(|i| state.can_build_robot(*i, blueprint, max_materials)).collect_vec();
    let mut best = best_so_far;

    // Try to build whatever robots are available
    for &robot_type in &robots_available {
        // Are you trying to build a robot that you could have built the previous turn,
        // but decided to skip instead? If so, you're stupid and we need to prune this branch
        if prev_skipped.map(|ls| ls.contains(&robot_type)).unwrap_or(false) {
            continue;
        }

        new_state.build_robot(robot_type, blueprint);
        let score = run_for_blueprint(&new_state, blueprint, max_materials, None, best);
        best = max(score, best);
        new_state.unbuild_robot(robot_type, blueprint);
    }

    // Doing nothing is always an option (though usually not a good one)
    // Running the worse option last helps a lot with best_score-based pruning
    let score = run_for_blueprint(&new_state, blueprint, max_materials, Some(&robots_available), best);
    best = max(score, best);

    best
}

// Determines the optimistic best material production from this state, assuming that
// we can build a robot for that material every turn from now until the end
fn optimistic_best(state: &SearchState, material: Material) -> u32 {
    let mat = material as usize;
    let i = state.time_remaining;
    
    state.materials[mat]    // The material that we already have...
    + state.robots[mat] * i // plus the material that will be generated by the existing robots...
    + i * (i-1) / 2         // plus the optimistic assumption that one new robot will be added every turn (1 + 2 + ... + i)
}

// Finds the maximum of any material needed in any recipe
fn get_max_materials(blueprint: &Blueprint) -> [u32; 4] {
    let mut maxs = [0, 0, 0, u32::MAX];

    for recipe in &blueprint.robot_recipes {
        for &(amount, material) in recipe {
            let i = material as usize;
            maxs[i] = max(maxs[i], amount);
        }
    }

    return maxs;
}

impl SearchState {
    fn can_build_robot(&self, robot_type: usize, blueprint: &Blueprint, max_materials: &[u32]) -> bool {
        let recipe = &blueprint.robot_recipes[robot_type];
        // Don't build this robot if we are already generating the maximum amount
        // of the robot's material per minute
        let maxed_out = self.robots[robot_type] >= max_materials[robot_type];
        !maxed_out && recipe.iter().all(|&(amount, material)| self.materials[material as usize] >= amount)
    }

    // Updates self to deduct materials and add one robot of the specified type
    // We assume that the robot can be built
    fn build_robot(&mut self, robot_type: usize, blueprint: &Blueprint) {
        self.robots[robot_type] += 1;
        for &(amount, material) in &blueprint.robot_recipes[robot_type] {
            self.materials[material as usize] -= amount;
        }
    }

    // Performs the opposite process to the previous function
    fn unbuild_robot(&mut self, robot_type: usize, blueprint: &Blueprint) {
        self.robots[robot_type] -= 1;
        for &(amount, material) in &blueprint.robot_recipes[robot_type] {
            self.materials[material as usize] += amount;
        }
    }
}

impl Blueprint {
    pub fn from_line(line: &str) -> Self {
        let mut id = 0;
        let mut ore_robot_ore_cost = 0;
        let mut clay_robot_ore_cost = 0;
        let (mut obs_robot_ore_cost, mut obs_robot_clay_cost) = (0, 0);
        let (mut geo_robot_ore_cost, mut geo_robot_obs_cost) = (0, 0);

        sscanf!(line, "Blueprint {}: Each ore robot costs {} ore. Each clay robot costs {} ore. Each obsidian robot costs {} ore and {} clay. Each geode robot costs {} ore and {} obsidian.", id, ore_robot_ore_cost, clay_robot_ore_cost, obs_robot_ore_cost, obs_robot_clay_cost, geo_robot_ore_cost, geo_robot_obs_cost).unwrap();

        let ore_robot = vec![(ore_robot_ore_cost, Ore)];
        let clay_robot = vec![(clay_robot_ore_cost, Ore)];
        let obsidian_robot = vec![(obs_robot_ore_cost, Ore), (obs_robot_clay_cost, Clay)];
        let geode_robot = vec![(geo_robot_ore_cost, Ore), (geo_robot_obs_cost, Obsidian)];

        Self { id, robot_recipes: [ore_robot, clay_robot, obsidian_robot, geode_robot] }
    }
}
